with open("config.json", "r", encoding="utf-8") as f:
    CONFIG = json.load(f)

# üîë –≥–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ä–µ–∂–∏–º–∞ —Ä–∞–±–æ—Ç—ã
CURRENT_MODE = {"value": "private"}  # –º–æ–∂–µ—Ç –±—ã—Ç—å "private" –∏–ª–∏ "public"

app = Flask(__name__)
app.secret_key = CONFIG["secret_key"]
USERS = CONFIG["users"]

import asyncio

vibration_queues = {user: asyncio.Queue() for user in CONFIG["profiles"].keys()}
CONNECTED_USERS = {}

# ---------------- LOVENSE ----------------
import hashlib

donation_logs = {user: [] for user in CONFIG["profiles"].keys()}


def login_required(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        if not session.get("user"):
            return redirect(url_for("login"))
        return f(*args, **kwargs)

    return wrapper


def load_logs_from_file(user):
    log_file = f"donations_{user}.log"
    try:
        with open(log_file, "r", encoding="utf-8") as f:
            return [line.strip() for line in f.readlines()]
    except FileNotFoundError:
        return []

# –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –∑–∞–ø–æ–ª–Ω—è–µ–º donation_logs –∏–∑ —Ñ–∞–π–ª–æ–≤ –∫–∞–∂–¥–æ–≥–æ –ø—Ä–æ—Ñ–∏–ª—è
donation_logs = {}

for profile_key in CONFIG["profiles"]:
    donation_logs[profile_key] = load_logs_from_file(profile_key)


def add_log(user, message):
    # —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã: 24-10-25 22:10
    ts = datetime.now().strftime("%d-%m-%y %H:%M")
    entry = f"{ts} | {message}"

    # –ø–∏—à–µ–º –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ñ–∞–π–ª –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—Ä–æ—Ñ–∏–ª—è
    log_file = f"donations_{user}.log"
    with open(log_file, "a", encoding="utf-8") as f:
        f.write(entry + "\n")

    # –¥–æ–±–∞–≤–ª—è–µ–º –≤ –ø–∞–º—è—Ç—å
    if user not in donation_logs:
        donation_logs[user] = []
    donation_logs[user].append(entry)
    if len(donation_logs[user]) > 200:
        donation_logs[user].pop(0)

    print(entry)

def generate_utoken(uid, secret="arina_secret_123"):
    raw = uid + secret
    return hashlib.md5(raw.encode("utf-8")).hexdigest()


def get_qr_code(user):
    profile = CONFIG["profiles"][user]
    url = "https://api.lovense.com/api/lan/getQrCode"

    uid = profile["uid"]  # ‚úÖ –≤–º–µ—Å—Ç–æ f"{user}_001"
    utoken = generate_utoken(uid)

    payload = {
        "token": profile["DEVELOPER_TOKEN"],
        "uid": uid,
        "uname": profile["uname"],
        "utoken": utoken,
        "callbackUrl": "https://arinairina.duckdns.org/lovense/callback?token=arina_secret_123",
        "v": 2,
    }

    r = requests.post(url, json=payload, timeout=10)
    data = r.json()
    print("–û—Ç–≤–µ—Ç –æ—Ç Lovense API:", data)
    if data.get("code") == 0 and "data" in data and "qr" in data["data"]:
        return data["data"]["qr"]
    if "message" in data and str(data["message"]).startswith("http"):
        return data["message"]
    return None


@app.route("/lovense/callback", methods=["POST"])
def lovense_callback():
    data = request.json or request.form
    print("üì© Callback –æ—Ç Lovense:", data)

    uid = data.get("uid")
    if uid:
        CONNECTED_USERS[uid] = {
            "utoken": data.get("utoken"),
            "toys": data.get("toys", {}),
        }
        # üîç –û—Ç–ª–∞–¥–∫–∞: –≤—ã–≤–æ–¥–∏–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ CONNECTED_USERS
        print(
            "üîê CONNECTED_USERS —Å–µ–π—á–∞—Å:",
            json.dumps(CONNECTED_USERS, indent=2, ensure_ascii=False),
        )
        return "‚úÖ Callback –ø—Ä–∏–Ω—è—Ç", 200
    return "‚ùå –ù–µ—Ç uid", 400


def send_vibration_cloud(user, strength, duration):
    profile = CONFIG["profiles"][user]
    uid = profile["uid"]  # ‚úÖ –±–µ—Ä—ë–º –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
    user_data = CONNECTED_USERS.get(uid)

    if not user_data:
        print(f"‚ùå [{user}] –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∏–∑ callback ‚Äî –∏–≥—Ä—É—à–∫–∞ –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞")
        return None

    utoken = user_data.get("utoken")
    if not utoken:
        print(f"‚ùå [{user}] utoken –ø—É—Å—Ç–æ–π ‚Äî –ø–µ—Ä–µ—Å–∫–∞–Ω–∏—Ä—É–π QR‚Äë–∫–æ–¥")
        return None

    url = "https://api.lovense.com/api/lan/v2/command"

    payload = {
        "token": profile["DEVELOPER_TOKEN"],  # Cloud Developer Token
        "uid": uid,
        "utoken": utoken,
        "command": "Function",
        "action": f"Vibrate:{strength}",
        "timeSec": duration,
    }

    try:
        print(f"üì§ [{user}] –û—Ç–ø—Ä–∞–≤–∫–∞ –≤–∏–±—Ä–∞—Ü–∏–∏ ‚Üí {payload}")  # üîç –ª–æ–≥ –ø–µ—Ä–µ–¥ –∑–∞–ø—Ä–æ—Å–æ–º
        r = requests.post(url, json=payload, timeout=10)
        print(f"üì• [{user}] –û—Ç–≤–µ—Ç Cloud API: {r.text}")  # üîç –ª–æ–≥ –æ—Ç–≤–µ—Ç–∞
        data = r.json()
        return data
    except Exception as e:
        print(f"‚ùå [{user}] –û—à–∏–±–∫–∞ Cloud‚Äë–≤–∏–±—Ä–∞—Ü–∏–∏:", e)
        return None


async def vibration_worker(user):
    q = vibration_queues[user]
    while True:
        try:
            strength, duration = await q.get()
            send_vibration_cloud(user, strength, duration)
            await asyncio.sleep(duration)
        except Exception as e:
            print(f"‚ö†Ô∏è [{user}] –û—à–∏–±–∫–∞ –≤ vibration_worker:", e)
        finally:
            q.task_done()


# ---------------- –ü–†–ê–í–ò–õ–ê ----------------
def load_rules(user):
    profile = CONFIG["profiles"][user]
    rules_file = profile["rules_file"]
    try:
        with open(rules_file, "r", encoding="utf-8") as f:
            return json.load(f)
    except:
        return {"default": [1, 5], "rules": []}


def apply_rule(user, amount, text):
    print(f"‚öôÔ∏è [{user}] apply_rule: —Å—É–º–º–∞={amount}, —Ç–µ–∫—Å—Ç={text}")
    rules = load_rules(user)

    for rule in rules.get("rules", []):
        if rule["min"] <= amount <= rule["max"]:
            action = rule.get("action")
            if action and action.strip():
                add_log(user, f"{amount} | –î–ï–ô–°–¢–í–ò–ï: {action}")
                update_stats(user, "actions", amount)
                return f"üé¨ –î–µ–π—Å—Ç–≤–∏–µ: {action}"

            # –µ—Å–ª–∏ –Ω–µ—Ç –¥–µ–π—Å—Ç–≤–∏—è, –∑–Ω–∞—á–∏—Ç —ç—Ç–æ –≤–∏–±—Ä–∞—Ü–∏—è
            strength = rule.get("strength", 1)
            duration = rule.get("duration", 5)
            vibration_queues[user].put_nowait((strength, duration))
            update_stats(user, "vibrations", amount)
            return f"üè∞ –í–∏–±—Ä–∞—Ü–∏—è: —Å–∏–ª–∞={strength}, –≤—Ä–µ–º—è={duration}"

    print(f"üö´ [{user}] –î–æ–Ω–∞—Ç {amount} –Ω–µ –ø–æ–ø–∞–¥–∞–µ—Ç –Ω–∏ –ø–æ–¥ –æ–¥–Ω–æ –ø—Ä–∞–≤–∏–ª–æ ‚Äî –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º")
    return None


# ---------------- VIP ----------------


def update_vip(user, user_id, name=None, amount=0, event=None):
    profile = CONFIG["profiles"][user]
    vip_file = profile["vip_file"]

    try:
        with open(vip_file, "r", encoding="utf-8") as f:
            vip_data = json.load(f)
    except:
        vip_data = {}

    # –µ—Å–ª–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω ‚Äî –Ω–µ –æ–±–Ω–æ–≤–ª—è–µ–º
    if user_id in vip_data and vip_data[user_id].get("blocked"):
        print(f"üö´ [{user}] –ú–µ–º–±–µ—Ä {user_id} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º")
        return vip_data.get(user_id)

    # –µ—Å–ª–∏ –Ω–æ–≤—ã–π ‚Äî —Å–æ–∑–¥–∞—ë–º
    if user_id not in vip_data:
        vip_data[user_id] = {
            "name": name or "–ê–Ω–æ–Ω–∏–º",
            "alias": "",
            "total": 0,
            "notes": "",
            "login_count": 0,
            "last_login": "",
            "blocked": False,
            "_just_logged_in": False,
        }

    # –æ–±–Ω–æ–≤–ª—è–µ–º –∏–º—è ‚Äî —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–æ –µ—â—ë –Ω–µ –∑–∞–¥–∞–Ω–æ –≤—Ä—É—á–Ω—É—é
    if name:
        current_name = vip_data[user_id].get("name", "")
        if not current_name or current_name == "–ê–Ω–æ–Ω–∏–º":
            vip_data[user_id]["name"] = name

    # –æ–±–Ω–æ–≤–ª—è–µ–º —Å—É–º–º—É
    if amount and amount > 0:
        vip_data[user_id]["total"] += amount

    # –æ–±–Ω–æ–≤–ª—è–µ–º –≤—Ö–æ–¥
    if event and event.lower() == "login":
        vip_data[user_id]["login_count"] += 1
        vip_data[user_id]["last_login"] = time.strftime("%Y-%m-%d %H:%M:%S")
        vip_data[user_id]["_just_logged_in"] = True

    with open(vip_file, "w", encoding="utf-8") as f:
        json.dump(vip_data, f, indent=2, ensure_ascii=False)

    return vip_data[user_id]  # ‚úÖ —Ç–µ–ø–µ—Ä—å –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å

